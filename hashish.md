# `x/hash-ish` 
This custom module serves to:
- register and keep track of new **streams** 
- keep track of storage location for users escies keys
- update merkle-tree of **[AEA](#creating-all-encrypted-actions-hash-aea)** signatures for a stream.
- allowing users to give Hash Plug API instances consent to raw priv key.

## Module Messages
|Message | Description |
|-|-|
|`MsgCreateStream`| Creates a new stream.|
|`MsgGrowStream`| Creates a new stream|
|`MsgClaimStreamRewards`| |
|`MsgRegisterAsStreamer`| stores an encrypted ecies pubkey for an address|
|`MsgRotateHashPlug`| rotates a `stream_id` merkle-leaf provider key|
|`MsgDistributeReward`| distirbutes rewards for a stream id.|


## Hash Plug API 
The Hash Plug API is an external, sibling service for x/hash-ish, that exists to:
- track all actions from a user session
- hash [all encrypted actions](#allencryptedactionshash) into a single value to store (AEA) 
- store AEA heuristically on Jackal for public reference and verification
- provide `x/hash-ish` the sha256sum of AEA, and the signature generated from the AEA, via `MsgGrowStream`.
- calculate rewards by fetching AHA from storage provider 

## Streaming Encryption Keys 
All actions tracked are encrypted client-side by ecies keys.

## Creating All Encrypted Actions Hash (AEA)
**AllEncryptedActionsHash** is the value generated by the Hash Plug API containing the encrypted action values. 

1. we start by creating a **file action tally** (fat) hash of the actions & their tallies of one address for a given file-id\
`fat = Hash(file_id,[(action,tally)])`

2. then the fat is encrypted into e-fat. this encryption is done with the combination of the ecies pubkey of the API, & the user of the actions being tracked. The API has the location of the users pubkey thanks to the module\
`fat -> e_fat`

3. next, we create a hash of all of the encrypted actions for one address\
`pkfats = Hash(pubkey, [e_fat])`

4. finally we hash all address pkfats into **AEA**\
`AEA = HASH([pkfats])`

This hash is what is signed by the API's key, and is what is merklized on-chain for verification.

### Encrypting Actions
The goal is to not store player actions on-state publically. To do this, we encrypt the actions tracked on the client side with a combination of the hash_plug_addr ecies key and the ecies key of an addr.

1. **obtain ecies key** When a session is started, the API request for the session's connected addr ecies key, which the off-chain file location is available on-chain, in `x/hash-ish`. If one does not exist, one is generated and stored.

2. **encrypt stored actions per addr** Each addr tracked actions are encrpyed with their key, and proceeds through the compression workflow.

## AEA Storage
This design concept does not involve the storage of the tracked encrypted actions on-chain. Instead, a merkle tree of the signature generated from the AEA, and a nonce of each update is defined as the sha256 of the AEA is provided to the module. This

### Heuristic Folder Naming 
We make use of the sha256 of the AHA & the stream_id for easy AHA folder desintation parsing. 

**AEA storage expectations**\
`/$API_DEFINED_HOME/$STREAM_ID/$SHA256_OF_AHA`

**ecies key storage expectations**\
pubkey:  `/$API_DEFINED_HOME/$USER_PUBKEY/$STREAM_ID/$PUBKEY-pubkey`\
private key: `/$API_DEFINED_HOME/$USER_PUBKEY/$STREAM_ID/$PUBKEY-privkey`

### Calculating Rewards 
When it is time to calulate rewards, the API should have:
- the off-chain storage location where the most recent AEA is stored. 
- the ecies pub key of tracked all clients cached in state
- the ecies key of itself

With these parameters, we can decrypt only the action values of address that have given the API consent for a specific stream_id. When we treat ecies keys as disposable per stream-id, providing consent to an API from a user perspective includes providing access to the unencrypted private key of the ecies, and generating fresh ones when using a new streaming platform. 

The API decrypts the actions for each address with its own key & the addresses key (which we are able to decrypt)and performs distribution computation logic that is programmable. 

### Claiming Rewards
Rewards are distributed automatically by the API calling the `MsgDistributeReward`
### Streams 
Streams are distribution instances within a module. A stream has its own:
|||
|-|-|
|**hash_plug_addr** | pubkey that is expected to sign tracked actions.|
|**action_merkle_tree**|merkle tree from signatures generated by **hash_plug_addr** from |
| **rewards_config** |reward distribution configuration |

### Stream Action Merkle Trees
When a stream is generated, the merkle tree root is created by hashing the **hash_plug_addr** & **stream_id** together.


## Workflow 
1. **account signs up** - this person will be generating streaming data and wants to be rewarded. Their ecies keys are stored off-chain, and file-path of these keys are encrypted and stored on-chain. 
2. **new stream is created** - a streaming platform creates new streaming incentives via `MsgCreateStream`.
3. **account provides consent to a stream** - a `stream_id` is approved to make use of their ecies key to encrypt their data.
4. **accounts performs stream actions**- these are tracked, tallied and hashed for each file by client during session.
5. **AEA signature & sha256 of AEA gets pushed to `stream_id` in `x/hash-ish`** 
6. **merkle tree of AEA signature is updated**